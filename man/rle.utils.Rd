% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rle_utils.R
\name{rle.utils}
\alias{rle.utils}
\alias{c.rle}
\alias{!.rle}
\alias{binop.rle}
\alias{|.rle}
\alias{&.rle}
\alias{compact.rle}
\title{RLE utilities}
\usage{
\method{c}{rle}(...)

\method{!}{rle}(x)

binop.rle(e1, e2, FUN)

\method{|}{rle}(e1, e2)

\method{&}{rle}(e1, e2)

compact.rle(x)
}
\arguments{
\item{...}{Objects to be concatenated. The first object must be of
class \code{\link[=rle]{rle()}}.}

\item{x, e1, e2}{Arguments to unary (\code{x}) and binary (\code{e1} and \code{e2})
operators.}

\item{FUN}{A binary function or operator or a name of one. It is
assumed to be vectorized: it expects two vectors of equal lengths
and outputs a vector of the same length.}
}
\value{
All functions return an \code{\link[=rle]{rle()}} object. By default, the
functions and the operators do not merge adjacent runs with
the same value. This must be done explicitly with \code{\link[=compact.rle]{compact.rle()}}.
}
\description{
Simple utilities for operations on RLE-encoded vectors.
}
\section{Functions}{
\itemize{
\item \code{binop.rle}: Perform an arbitrary binary operation on the pair of vectors
represented by the \code{\link[=rle]{rle()}} objects.

\item \code{compact.rle}: Compact the \code{\link[=rle]{rle()}} object by merging adjacent runs.
}}

\note{
\code{\link[=compact.rle]{compact.rle()}} may not be safe if the combined run lenth
exceeds the maximum value representable by a 32-bit signed
integer (\Sexpr{.Machine$integer.max}).
}
\examples{

x <- rle(as.logical(rbinom(10,1,.7)))
y <- rle(as.logical(rbinom(10,1,.3)))

stopifnot(c(inverse.rle(x),inverse.rle(y))==inverse.rle(c(x,y)))

stopifnot((!inverse.rle(x))==inverse.rle(!x))
stopifnot((inverse.rle(x)|inverse.rle(y))==inverse.rle(x|y))
stopifnot((inverse.rle(x)&inverse.rle(y))==inverse.rle(x&y))
stopifnot(identical(rle(inverse.rle(x)&inverse.rle(y)),compact.rle(x&y)))
}
